# 专题文章精选功能修复报告

**问题接口**: `/api/topics/:id/set-article-featured`
**错误代码**: 1007 (系统错误)
**修复时间**: 2025-11-30
**影响范围**: 专题文章管理功能

---

## 🔍 问题分析

### 错误信息

```
json_decode(): Argument #1 ($json) must be of type string, array given
[D:\work\cms\backend\app\controller\api\TopicController.php:541]
```

### 根本原因

在 `Relation` 模型中，`extra` 字段被定义为 **JSON类型**：

```php
// backend/app/model/Relation.php 第22行
protected $type = [
    'source_id' => 'integer',
    'target_id' => 'integer',
    'sort' => 'integer',
    'site_id' => 'integer',
    'extra' => 'json',  // ← JSON类型自动转换
];
```

**ThinkPHP行为**:
- 从数据库读取时：自动将JSON字符串反序列化为PHP数组
- 保存到数据库时：自动将PHP数组序列化为JSON字符串

**问题代码**:
```php
// 第541行 - 错误地对数组调用json_decode()
$extra = json_decode($relation->extra ?? '{}', true) ?: [];
$extra['is_featured'] = $isFeatured;
$relation->extra = json_encode($extra);  // 错误地手动编码
```

因为 `$relation->extra` 已经是数组，再调用 `json_decode()` 会导致类型错误。

---

## ✅ 修复内容

### 1. 修复 `setArticleFeatured()` 方法 (第542-549行)

**修复前**:
```php
if ($relation) {
    $extra = json_decode($relation->extra ?? '{}', true) ?: [];
    $extra['is_featured'] = $isFeatured;
    $relation->extra = json_encode($extra);
    $relation->save();
}
```

**修复后**:
```php
if ($relation) {
    // extra字段已被ThinkPHP自动反序列化为数组，无需json_decode
    $extra = is_array($relation->extra) ? $relation->extra : [];
    $extra['is_featured'] = $isFeatured;
    // ThinkPHP会自动序列化为JSON，无需json_encode
    $relation->extra = $extra;
    $relation->save();
}
```

---

### 2. 修复 `articles()` 方法 (第374-381行)

**修复前**:
```php
foreach ($list->items() as &$article) {
    $relation = $topicArticles->where('target_id', $article->id)->first();
    $article->topic_sort = $relation ? $relation->sort : 0;
    $article->is_featured = $relation ? ($relation->extra['is_featured'] ?? 0) : 0;
}
```

**修复后**:
```php
foreach ($list->items() as &$article) {
    $relation = $topicArticles->where('target_id', $article->id)->first();
    $article->topic_sort = $relation ? $relation->sort : 0;
    // extra字段已被ThinkPHP自动反序列化为数组
    $extra = $relation && $relation->extra ? $relation->extra : [];
    $article->is_featured = is_array($extra) ? ($extra['is_featured'] ?? 0) : 0;
}
```

**改进**: 添加了 `is_array()` 检查，防止 `extra` 为 `null` 或其他非数组值时出错。

---

### 3. 修复 `addArticle()` 方法 (第423-434行)

**修复前**:
```php
Relation::create([
    'source_type' => 'topic',
    'source_id' => $id,
    'target_type' => 'article',
    'target_id' => $articleId,
    'sort' => $sort,
    'extra' => json_encode(['is_featured' => $isFeatured]),  // 错误地手动编码
    'site_id' => 1,
]);
```

**修复后**:
```php
Relation::create([
    'source_type' => 'topic',
    'source_id' => $id,
    'target_type' => 'article',
    'target_id' => $articleId,
    'sort' => $sort,
    // ThinkPHP会自动序列化数组为JSON
    'extra' => ['is_featured' => $isFeatured],
    'site_id' => 1,
]);
```

**改进**: 直接传递PHP数组，让ThinkPHP自动序列化。

---

## 📋 修改文件清单

| 文件路径 | 修改行数 | 修改内容 |
|---------|---------|---------|
| `backend/app/controller/api/TopicController.php` | 374-381 | 修复 `articles()` 方法中的 `extra` 字段读取 |
| `backend/app/controller/api/TopicController.php` | 423-434 | 修复 `addArticle()` 方法中的 `extra` 字段写入 |
| `backend/app/controller/api/TopicController.php` | 542-549 | 修复 `setArticleFeatured()` 方法中的 `extra` 字段读写 |

---

## 🎯 ThinkPHP JSON字段自动转换规则

### 模型定义
```php
protected $type = [
    'extra' => 'json',  // 声明为JSON类型
];
```

### 读取行为
```php
$relation = Relation::find(1);
// 数据库: {"is_featured": 1, "other": "value"}
// $relation->extra 自动转换为: ['is_featured' => 1, 'other' => 'value']
```

### 写入行为
```php
$relation->extra = ['is_featured' => 1];  // 传入PHP数组
$relation->save();
// 自动序列化为: {"is_featured": 1}
```

### 错误用法 ❌
```php
// 读取时 - 不要手动解码（已经是数组）
$extra = json_decode($relation->extra, true);  // ❌ 错误

// 写入时 - 不要手动编码（ThinkPHP会自动编码）
$relation->extra = json_encode(['key' => 'value']);  // ❌ 错误
```

### 正确用法 ✅
```php
// 读取时 - 直接使用（已经是数组）
$extra = $relation->extra;  // ✅ 正确
$isFeatured = $extra['is_featured'] ?? 0;  // ✅ 正确

// 写入时 - 直接赋值数组（ThinkPHP自动编码）
$relation->extra = ['is_featured' => 1];  // ✅ 正确
```

---

## ✅ 测试验证

### 1. 测试设置文章为精选

```bash
# 请求
curl -X POST http://localhost:8000/api/topics/9/set-article-featured \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "article_id": 25,
    "is_featured": 1
  }'

# 预期响应
{
  "code": 0,
  "message": "设置成功",
  "data": null
}
```

### 2. 测试获取专题文章列表

```bash
# 请求
curl -X GET http://localhost:8000/api/topics/9/articles \
  -H "Authorization: Bearer YOUR_TOKEN"

# 预期响应
{
  "code": 0,
  "message": "success",
  "data": {
    "list": [
      {
        "id": 25,
        "title": "文章标题",
        "topic_sort": 0,
        "is_featured": 1  // ← 正确显示精选状态
      }
    ]
  }
}
```

### 3. 测试添加文章到专题

```bash
# 请求
curl -X POST http://localhost:8000/api/topics/9/add-article \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "article_id": 26,
    "sort": 0,
    "is_featured": 1
  }'

# 预期响应
{
  "code": 0,
  "message": "添加成功",
  "data": null
}
```

---

## 🐛 常见问题

### Q1: 为什么会出现这个错误？

**A**: ThinkPHP的JSON类型自动转换机制导致。当模型字段定义为`json`类型时，框架会自动处理序列化/反序列化，开发者不需要手动调用`json_encode()`和`json_decode()`。

### Q2: 其他地方是否有类似问题？

**A**: 建议检查所有使用`Relation`模型`extra`字段的地方，确保：
- 读取时不使用`json_decode()`
- 写入时不使用`json_encode()`
- 使用前检查`is_array()`确保数据类型正确

### Q3: 如何避免类似问题？

**A**:
1. 查看模型的`$type`属性，了解哪些字段有自动转换
2. 对于JSON字段，直接使用PHP数组操作
3. 添加类型检查（`is_array()`）增加健壮性

---

## 📝 最佳实践

### 1. 使用JSON字段的推荐写法

```php
// ✅ 推荐：安全的读取方式
$extra = is_array($relation->extra) ? $relation->extra : [];
$isFeatured = $extra['is_featured'] ?? 0;

// ✅ 推荐：安全的写入方式
$extra = is_array($relation->extra) ? $relation->extra : [];
$extra['is_featured'] = 1;
$relation->extra = $extra;
$relation->save();
```

### 2. 模型定义规范

```php
class Relation extends Model
{
    // 明确声明JSON字段
    protected $json = ['extra'];

    // 或使用类型转换
    protected $type = [
        'extra' => 'json',
    ];

    // 设置默认值
    protected $defaultValue = [
        'extra' => [],
    ];
}
```

---

## 🎉 总结

✅ **问题已解决**: 修复了3个与JSON字段相关的错误
✅ **根本原因**: ThinkPHP自动转换机制与手动序列化冲突
✅ **修复方法**: 移除手动的`json_encode()`和`json_decode()`调用
✅ **增强健壮性**: 添加类型检查防止异常

**现在专题文章精选功能可以正常使用了！** 🎉

---

**修复时间**: 2025-11-30
**影响版本**: 所有使用`Relation`模型的功能
**兼容性**: 向后兼容，无需修改数据库
